---
layout: post
title: '[转贴] Pointers to C++ Member Functions'
date: 2008-10-08 15:38:00.000000000 +08:00
type: post
published: true
status: publish
categories:
- 未分类
tags: []
meta: {}
author:
  login: kzjeef
  email: kzjeef@gmail.com
  display_name: kzjeef
  first_name: ''
  last_name: ''
---
<h1><a name="title"></p>
<p></a></h1>
<p><i>这篇文章很好的讲述了指向成员函数的指针怎么用， 后面对性能做了分析很精彩。</p>
<p></i></p>
<p><i>A tutorial on a useful yet poorly understood language feature, useful as a cache or to enable a different sort of polymorphism.</i></p>
<p><a href="http://www.goingware.com/tips/">Michael D. Crawford</a></p>
<p><a href="mailto:crawford@goingware.com">crawford@goingware.com</a></p>
<blockquote><p><!-- Copyright (C) 2002 Michael D. Crawford -->
<p>Copyright © 2002 Michael D. Crawford.</p>
<p><!-- Creative Commons License --><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" src="{{ site.baseurl }}/assets/somerights20.gif" /></a></p>
<p>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<!-- /Creative Commons License --><!--<rdf:rdf xmlns="http://web.resource.org/cc/" dc="http://purl.org/dc/elements/1.1/" rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><work about="">   <dc:title>Pointers to C++ Member Functions</dc:title>   <dc:date>2002</dc:date>   <dc:description>A tutorial on a useful yet poorly understood language feature, useful as a cache or to enable a different sort of polymorphism.</dc:description>   <dc:creator><agent>      <dc:title>Michael D. Crawford</dc:title>   </agent></dc:creator>   <dc:rights><agent>      <dc:title>Michael D. Crawford</dc:title>   </agent></dc:rights>   <dc:type resource="http://purl.org/dc/dcmitype/Text">   <dc:source resource="http://www.goingware.com/tips/member&#45;pointers.html">
<license resource="http://creativecommons.org/licenses/by-sa/2.5/"></work>
<license about="http://creativecommons.org/licenses/by-sa/2.5/">
<permits resource="http://web.resource.org/cc/Reproduction">
<permits resource="http://web.resource.org/cc/Distribution">   <requires resource="http://web.resource.org/cc/Notice">   <requires resource="http://web.resource.org/cc/Attribution">
<permits resource="http://web.resource.org/cc/DerivativeWorks">   <requires resource="http://web.resource.org/cc/ShareAlike"></license></rdf:RDF>--></p>
</blockquote>
<h2><a name="abstract">Abstract</a></h2>
<p> <i>Pointers to Member Functions</i> are one of C++'s more rarely used features, and are often not well understood even by experienced developers. This is understandable, as their syntax is necessarily rather clumsy and obscure.</p>
<p> While they do not have wide applicability, sometimes member function pointers are useful to solve certain problems, and when they do apply they are often the perfect choice, both for improved performance and to make the code sensible. They work very well to cache the result of a frequently made decision, and to implement a different sort of polymorphism.</p>
<p>I discuss what member function pointers are, how to declare and use them, and give some examples of problems that they solve very well.</p>
<h2><a name="contents">Contents</a></h2>
<ul>
<li><a href="http://linuxquality.sunsite.dk/articles/memberpointers/#abstract">Abstract</a></li>
<li><a href="http://linuxquality.sunsite.dk/articles/memberpointers/#introduction"> Introduction</a></li>
<li><a href="http://linuxquality.sunsite.dk/articles/memberpointers/#not-addresses"> Member Function Pointers Are Not Just Simple Addresses</a></li>
<li><a href="http://linuxquality.sunsite.dk/articles/memberpointers/#decision-cache"> Caching the Outcome of a Decision</a></li>
<li><a href="http://linuxquality.sunsite.dk/articles/memberpointers/#performance"> The Performance of Member Function Pointers</a></li>
<li><a href="http://linuxquality.sunsite.dk/articles/memberpointers/#details"> Details About Using Member Function Pointers</a></li>
<li><a href="http://linuxquality.sunsite.dk/articles/memberpointers/#polymorphism"> A Different Sort of Polymorphism</a></li>
</ul>
<h2><a name="introduction">Introduction</a></h2>
<p> I don't have any hard numbers on how frequently member function pointers are used. While Ido see others mention them sometimes in Usenet and mailing list posts, I have yet to find someoneelse use one in code I have worked with, so my impression is that they are not commonly applied.</p>
<p> Member function pointers are important because they provide an efficient way to cache the outcome of a decision over which member function to call. They can save time, and in some cases, provide a design alternative that avoids the need to implement such decision caching through memory allocation. I will return to this further on.</p>
<p> Member function pointers allow one to call one of several of an object's member functions indirectly. Each of the functions whose "address" is stored must share the same signature. </p>
<p> I put "address" in quotes because the information stored in a member function pointer is not simply the memory address of the start of the member function's code; conceptually it is an offset into the list of functions declared by the class, and in the case of virtual functions will include a real offset into the <code>vtbl</code>, or table of virtual function pointers.</p>
<p> Member function pointers cannot be dereferenced (have their function called) directly by themselves. They must be called on behalf of some object, that then provides the "this" pointer for use by the member functions.</p>
<p> To illustrate how to declare and call a member function pointer, I will start by giving an example ofdeclaring and dereferencing an ordinary pointer to a non-member function. You declare a functionpointer by giving the prototype of a function it can point to, with the name of the function replacedby <code>(*pointerName)</code>.  Regular function pointers share the same syntax between C and C++:</p>
<blockquote><pre>void Foo( int anInt, double aDouble );void Bar(){       <strong> void (*funcPtr)( int, double ) = &Foo;</strong> <strong>(*funcPtr)( 1, 2.0 );</strong>}</pre>
</blockquote>
<p> For regular function pointers, it is optional to use the address-of operator <code>&</code> when taking the address of a function, but it is required for taking the address of member functions. g++ will compile source that leaves it out, but emits a warning.</p>
<p> To declare a pointer to member function, you give the prototype of a function it can point to, as before, but the name of this function is replaced by a construction that scopes the pointer - you give it the name of the class whose member functions it can point to, as <code>(ClassName::*pointerName)</code>. Note that a given member function pointer can only point to functions that are members of the class it was declared with. It cannot be applied to an object of a different class even if it has member functions with the same signature.</p>
<p> You dereference a member function pointer by using <code>.*</code> or <code>->*</code>, supplying a reference or pointer to an object on the left, as appropriate, and the function pointer on the right.</p>
<p> Here is a simple example:</p>
<blockquote><pre>class Foo{       <br /><br />public:<br /><br />              double One( long inVal );<br /><br />              double Two( long inVal );<br /><br />};<br /><br />void main( int argc, char **argv )<br /><br />{	<strong><br /><br />   double (Foo::*funcPtr)( long ) = &Foo;::One;</strong> <br /><br />      Foo aFoo;<br /><br /> <strong>double result =(aFoo.*funcPtr)( 2 );<br /><br /> </strong>return 0;<br /><br />}</pre>
</blockquote>
<p> Declaring a member function pointer is clumsy at best and is hard to get right until you have used them for a while. Rather than declaring them using the full prototype each time, it is helpful to use a <code>typedef</code> as I show in the example below.</p>
<h2><a name="not-addresses">Member Function Pointers Are Not Just Simple Addresses</a></h2>
<p> Most C and C++ programmers know that it is bad style to assume that a pointer is the same size as an int, although this may often be the case. What is less well known is that pointers of different types may not be the same size as each other. For example, in 16-bit x86 programming near pointers and far pointers may have different sizes, where the far pointers consist of the segment and offset together, while near pointers just have the offset. Member function pointers are generally small structures, that encode information about a function's virtualness, multiple inheritance and so on.</p>
<p> In the case of the example shown below, compiled with g++ 2.95.2 on a PowerPC G3 Mac OS X iBook, I found that the size of the member function pointer I created was eight bytes.</p>
<p> This can result in surprises to the user. For example, Microsoft Visual C++ 6 allows the programmer to make an optimization (which is apparently enabled by default) which can cause member function pointers that are intended to be the same type but are declared in different circumstances to have different sizes. Using the wrong setting for your project may result in an apparently gross code generation bug, because a member function pointer returned by a function that supplies them may have a different size than the recipient function expects, causing bogus data to be overwritten on the stack.</p>
<p> There is an item in VC++'s settings labeled "representation" that has a choice between "best case always" and "most general always". If you work with member function pointers in Visual C++, check the documentation for what these settings do and select the right one; if in doubt, select "most general always".</p>
<h2><a name="decision-cache">Caching the Outcome of a Decision</a></h2>
<p> One of the best uses for member function pointers is caching the outcome of a decision over which ofseveral member functions should be called in a particular circumstance. If a decision is always going to yield the same result, then it may be faster and even cleaner to make the decision just once ahead of time, then store the outcome in the form of a member function pointer. This is especially advantageous when the decision will be made repeatedly in a loop.</p>
<p> Here is an admittedly silly (but hopefully clear) example, that shows a member function pointer being used to store the outcome of a decision. It also illustrates the use of <code>typedef</code>:</p>
<blockquote><pre>#include <stdlib.h><br /><br />#include <iostream><br /><br />class Test{<br /><br /> public:<br /><br /> Test( long inVal )<br /><br /> : mVal( inVal )<br /><br />{}<br /><br /> long TimesOne() const;<br /><br /> long TimesTwo() const;<br /><br /> long TimesThree() const;<br /><br /> private:	<br /><br />	long mVal;<br /><br />};<br /><br /><strong><br /><br />typedef long (Test::*Multiplier)() const;</strong><br /><br />int main( int argc, char **argv )<br /><br />{<br /><br /> using std::cerr;<br /><br /> using std::endl;<br /><br /> using std::cout;<br /><br /> if ( argc != 3 ){<br /><br /> cerr  << "Usage: PtrTest value factor"  << endl;<br /><br /> return 1;<br /><br /> }<br /><br /> <strong>Multiplier funcPtr;</strong><br /><br /> switch( atol( argv[ 2 ] ) ){<br /><br /> case 1:<br /><br /> <strong>funcPtr = &Test;::TimesOne;</strong><br /><br /> break;<br /><br /> case 2:			<strong><br /><br />funcPtr = &Test;::TimesTwo;</strong><br /><br /> break;		<br /><br />case 3:			<strong><br /><br />funcPtr = &Test;::TimesThree;</strong><br /><br /> break;		<br /><br />default:			<br /><br />cerr << "PtrTest: factor must range from 1 to 3"  << endl;			<br /><br />return 1;	<br /><br />}	<br /><br />cout  << "sizeof( funcPtr )="  << sizeof( funcPtr )  << endl;<br /><br /> Test myTest( atol( argv[ 1 ] ) );<br /><br /> cout << "result="  << <strong>(myTest.*funcPtr)()</strong>  <<endl><br /><br /> return 0;<br /><br />}<br /><br />long Test::TimesOne() const{<br /><br /> return mVal;<br /><br />}<br /><br />long Test::TimesTwo() const{<br /><br /> return 2 * mVal;<br /><br />}<br /><br />long Test::TimesThree() const{<br /><br /> return 3 * mVal;<br /><br />}</endl></iostream></stdlib.h></pre>
</blockquote>
<p> Now I present an example that does not perform as well as it could because performs a <code>switch</code> decision many times inside a loop, always reaching the same decision. It is a good candidate to refactor by using a pointer to member function. Again it is a silly example but I wanted to be very clear:</p>
<blockquote><pre>#include <exception>class Test{<br /><br /> public:	<br /><br />	Test( long inFactor )	<br /><br />		: mFactor( inFactor ){}<br /><br /> long TimesOne( long inToMultiply ) const;<br /><br /> long TimesTwo( long inToMultiply ) const;<br /><br /> long TimesThree( long inToMultiply ) const;	<br /><br />	long MultiplyIt( long inToMultiply ) const;<br /><br /> private:	<br /><br />	long mFactor;};<br /><br />long Test::MultiplyIt( long inToMultiply ) const{<br /><br /> <strong>switch( mFactor ){<br /><br /> // decision made repeatedly that always yields the same result</strong> <br /><br /><br /><br />case 1:			<br /><br />return TimesOne( inToMultiply );			<br /><br />break;		<br /><br />case 2:	<br /><br />		return TimesTwo( inToMultiply );		<br /><br />break;		<br /><br />case 3:			<br /><br />return TimesThree( inToMultiply );		<br /><br />	break;		<br /><br />default:			<br /><br />throw std::exception();	<br /><br />}<br /><br />}<br /><br />void MultiplyThem( long inFactor )<br /><br />{	<br /><br />Test myTest( 2 );	<br /><br />	long product;	// Call a function that makes the same decision many times	<br /><br /><br /><br />for ( long i = 0; i < 1000000; ++i )		<br /><br />product = myTest.MultiplyIt( i );<br /><br />}</exception></pre>
</blockquote>
<p> In most cases where an identical decision is made inside a loop, it is better to refactor the code so that thedecision is outside the loop, and the loop is repeated in each branch of the loop (or packaged inside a subroutine):</p>
<blockquote><pre>void Foo( long value ){	for ( long i = 0; i < 1000000; ++i ){	<br /><br /> <strong>switch( value ){	<br /><br />	// BAD CODE: always reaches the same decision</strong> <br /><br />		case 1:				//...			<br /><br />	break;			case 2:			<br /><br />	//...				break;			<br /><br />case 3:				//...				<br /><br />break;		}<br /><br /> }<br /><br />}<br /><br /><br /><br /></pre>
</blockquote>
<p> Instead we place the switch outside the loop:</p>
<blockquote><pre>void Foo( long value ){	<strong>switch( value ){	<br /><br />	// BETTER CODE: decision made only once</strong> <br /><br />	case 1:		<br /><br />	for ( long i = 0; i < 1000000; ++i ){	<br /><br />			//...			<br /><br />}			<br /><br />break;		<br /><br />case 2:			<br /><br />for ( long i = 0; i < 1000000; ++i ){			<br /><br />	//...		<br /><br />	}		<br /><br />	break;		<br /><br />//...<br /><br /> }<br /><br />}</pre>
</blockquote>
<p> If you want to avoid repeating the loop implementations and each branch of the decision has similar code, you can place them inside subroutines.</p>
<p> <i>Member function pointers are the best solution when it is not practical to refactor this way.</i> Onereason might be that the loop and the decision are in code that belongs to different classes, and you do not want to expose the implementation of the class that makes the decision. Here is the <code>MultiplyIt</code> code above, refactored to use a pointer to member function:</p>
<blockquote><pre>#include <exception>class Test{	public:		Test( long inFactor );		long TimesOne( long inToMultiply ) const;		long TimesTwo( long inToMultiply ) const;		long TimesThree( long inToMultiply ) const;		long MultiplyIt( long inToMultiply ) const;	private:		<strong>typedef long (Test::*Multiplier)( long inToMultiply ) const;</strong>		long       mFactor;		<strong>Multiplier mMultFuncPtr;		static Multiplier GetFunctionPointer( long inFactor );</strong>};Test::Test( long inFactor )	: mFactor( inFactor ),	 <strong> mMultFuncPtr( GetFunctionPointer( mFactor ) )</strong>{	return;}<strong>Test::Multiplier Test::GetFunctionPointer( long inFactor )</strong>{	<strong>switch ( inFactor ){	// Decision only made once!</strong>		case 1:			<strong>return &Test;::TimesOne;</strong>			break;		case 2:			<strong> return &Test;::TimesTwo;</strong>			break;		case 3:			<strong> return &Test;::TimesThree;</strong>			break;			default:			throw std::exception();	}}			long Test::MultiplyIt( long inToMultiply ) const{	<strong>// Using cached decision result	return (this->*mMultFuncPtr)( inToMultiply );	</strong>}void MultiplyThem( long inFactor ){	Test myTest( 2 );		long product;	for ( long i = 0; i < product =" myTest.MultiplyIt("></exception></pre>
</blockquote>
<h2><a name="performance">The Performance of Member Function Pointers</a></h2>
<p> Unfortunately, calling a member function by dereferencing a member function is more complicated than simply doing a subroutine jump off a register. The pointers are actually small structures and a little bit of work is required to find the actual address of the subroutine to jump to.</p>
<p> I'm afraid I do not have the g++ source code at hand or I could show you the implementation. I know that in tracing through calls via member function pointers in <a href="http://www.metrowerks.com/">Metrowerks</a> CodeWarrior for Windows, I found that a call would run a small piece of assembly code provided by CodeWarrior's library. This is pretty fast code, and will run very fast in a tight loop if it stays in the CPU's L1 cache, but it is not as fast as a simple compare and conditional branch.</p>
<p> If the decision your code is making repeatedly is very quick to run, it may not be to your advantage to use a member function pointer. A simple <code>if</code> statement that compares two numeric values, or checks the value of a <code>bool</code>, or possibly a <code>switch</code> statement whose alternatives are all contained in a small range (so it is easy for the compiler to build a jump table) may be quicker than dereferencing a member function pointer.</p>
<p> However, if the decision is complicated or lengthy to arrive at, like string comparison or searching some data structure, then using a pointer to member function may be a big win.</p>
<h2><a name="details">Details About Using Member Function Pointers</a></h2>
<p> You may understand the reasons for implementing pointers to member functions as structures if you see that they can be assigned to the addresses of routines with different kinds of implementations, as long as they have the same calling convention:</p>
<blockquote><pre>class Different{	public:		inline void InlineMember();		virtual void VirtualMember();		void OrdinaryMember();		static void StaticMember();		typedef void (Different::*FuncPtr)();};void Test(){	Different::FuncPtr ptr = &Different;::InlineMember;	ptr = &Different;::VirtualMember;	ptr = &Different;::OrdinaryMember;}</pre>
</blockquote>
<p>(You may be surprised to see me creating a pointer to an inline function, but this is perfectly normal. If you do this, the compiler will place a normal subroutine version of the inline's implementation in an object file and give you the address of that, so the function pointer does not really point to an inline function at all.)</p>
<p> However, although a static member function may appear to have the same calling convention, it really does not because it is not passed the <code>this</code> pointer - <code>this</code> is passed to your member functions just like any other parameter, but it is not given explicitly in the member function's prototype. You cannot use pointers to member functions to store the address of a static function (use an ordinary, non-member function pointer for that):</p>
<blockquote><pre>void Fails(){      <br /><br />Different::FuncPtr ptr = &Different;::StaticMember;}<br /><br /><br /><br />mike% c++ different.cppdifferent.cpp: In function `void Fails()':different.cpp:24: initialization to `void (Different::*)()' from `void (*)()'</pre>
</blockquote>
<p> Pointers to virtual member functions work just like calling a virtual member function directly - the type whose member function gets called is the dynamic type of the object it is called on behalf of, not the static type of the member function pointer:</p>
<blockquote><pre>#include <iostream>class Base{	public:		virtual void WhoAmI() const;		<strong>typedef void (Base::*WhoPtr)() const;</strong>};class Derived: public Base{	public:		virtual void WhoAmI() const;};void Base::WhoAmI() const{	std::cout << "I am the Base" <<strong>Base::WhoPtr func = &Base;::WhoAmI;</strong>	Base theBase;	<strong>(theBase.*func)();</strong>	Derived theDerived;	<strong>(theDerived.*func)();</strong>	return 0;}</iostream></pre>
</blockquote>
<p> Running the above program yields the following output:</p>
<blockquote><pre>mike% ./virtual<strong>I am the BaseI am the Derived</strong></pre>
</blockquote>
<h2><a name="polymorphism">A Different Sort of Polymorphism</a></h2>
<p> Polymorphism in C++ is usually regarded as always implemented in the form of class heirarchies containing virtual member functions. </p>
<p> An object of a derived class can be supplied to create a pointer or reference to what is apparently the base class; a function pointer lookup in the <code>vtbl</code> is done when calling a virtual member function off a pointer or reference, so that the function called will be based on the dynamic type that the pointer or reference denotes - that is, it will be from the actual type of the object that was allocated, rather than the static type that the base class pointer or reference is declared as.</p>
<p> However, the concept of polymorphism can take a more general meaning than that, and I have seen mailing list postings advocating that it should also include the use of templates that allow source code with identical syntax to be applied to objects of unrelated types. This <code>std::vector</code> can be regarded as a polymorphic container that is parameterized by the type supplied as a parameter when a vector object is declared.</p>
<p> Pointers to member functions can be used to implement a different kind of polymorphism. In the regular type, we determine which member function ultimately gets called by allocating objects of different types, that are related members in an inheritance tree. This is implemented by having the <code>vptr</code> that is a hidden member of the object point at the appropriate <code>vtbl</code>.</p>
<p> In this other form you create objects that are always of the same type, but determine which member function gets called by choosing which member function's address gets assigned to a member function pointer. One interesting advantage is that you can change the behaviour of an object during its lifetime without having to allocate a new one of a different type as you would with the regular sort of inheritance-based polymorphism.</p>
<p>[<a href="http://linuxquality.sunsite.dk/">Linux Quality Database</a>][<a href="http://linuxquality.sunsite.dk/articles/">Articles</a>][<a href="http://linuxquality.sunsite.dk/articles/memberpointers/#title">Top</a>]</p>
<p> <a href="http://validator.w3.org/check/referer"><img src="{{ site.baseurl }}/assets/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a> </p>
