---
layout: post
title: 八皇后问题的实现
date: 2007-10-23 19:42:00.000000000 +08:00
type: post
published: true
status: publish
categories:
- 未分类
tags: []
meta:
  _wpas_skip_2244581: '1'
  _edit_last: '1'
  _wpas_skip_2244592: '1'
  _wpas_skip_2244573: '1'
  _wpas_skip_2244563: '1'
author:
  login: kzjeef
  email: kzjeef@gmail.com
  display_name: kzjeef
  first_name: ''
  last_name: ''
---
<p>最近重新复习了一下沙特人的算法书， 根据他的算法实现了8皇后问题，<br />
自己用C做了一个实现。<br />
12个皇后的问题在我的机器（AMD 3000＋， 256，LINUX 2.6）上运行了4.7秒左右，<br />
后来在忘上又找了一个实现,这是<a title="八皇后问题" href="http://c2.com/cgi/wiki?EightQueensInManyProgrammingLanguages">链接</a>， 他的竟然只用0.04秒。SO 快。<br />
佩服。<br />
贴上代码：<br />
我的：</p>
<pre>
#include 
#include 

long nqueens(int);
int test_queens(const char *,const int , const int);

int main(void)
{
assert (nqueens(12) == 14200);
//assert (nqueens(13) == 73712);
}

long
nqueens(int n)
{
register int key = 0;
int scount = 0;
char retv[20];
int test_val;
memset(retv, 0, 20);
while( key &gt;= 0) {
while( retv[key] &lt;= n-1) { // n-1 means zero was a position
retv[key] = retv[key] + 1;
if ( (test_val = test_queens(retv,key, n)) == 1) //part answer
key++;
else if (test_val == 0)
{
scount++;
}
}
retv[key] = 0;
key--;
}
outter:
return(scount);
}

// if queens is illegel result return -1
// else if queens is legel return 0
// or part result return 1
int test_queens(const register char *v,const int key, const register int n)
{
for (int i = 0; i &lt; n; i++) {
char vi = v[i], vk = v[key];
if (vi == 0 || vk == 0 )return 1;
if( i == key ) continue;
if (vi == vk || vk-vi == key - i || vk-vi == i - key)
return -1;
}
return 0;
}
</pre>
<p>&gt;time ./my<br />
real 0m0.556s<br />
user 0m0.552s<br />
sys 0m0.000s</p>
<p>那位兄台的</p>
<pre>
  #include <stdio.h>
  #include <stdlib.h>
  #include <limits.h>

  typedef unsigned long ulong;

  static const ulong ulong_bit = sizeof(ulong) * CHAR_BIT;

  static inline ulong search(ulong lb, ulong cb, ulong rb, ulong cnt) {
    if (~0ul == cb)
      cnt += 1;
    else
      for (ulong bs = lb | cb | rb; ~0ul != bs;) {
        ulong b = ~bs & (bs+1);
        bs |= b;
        cnt = search((lb | b) << 1, cb | b, (rb | b) >> 1, cnt);
      }
    return cnt;
  }

  static inline ulong nQs(ulong m) { return search(0, ~0ul >> m, 0, 0); }

  int main(int argc, char* argv[]) {
    ulong a = argc < 2 ? ulong_bit : atol(argv[1]);
    ulong n = a < ulong_bit ? a : ulong_bit;
    for (ulong i=1; i<=n; ++i)
      printf("%li: %li total solutionsn", i, nQs(i));
    return 0;
  }

</limits.h></stdlib.h></stdio.h></pre>
<p>&gt;time ./internet<br />
12: 14200 total solutions</p>
<p>real 0m0.081s<br />
user 0m0.024s<br />
sys 0m0.004s</p>
<p>这段代码用了尾递归， bit map，真是佩服这样的抠的精神。</p>
